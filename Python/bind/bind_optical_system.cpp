/**
* @file bind_optical_system.cpp
* @brief Defines the bind_optical_system function
* @author Bács Tamás <tamas.bacs@stud.ubbcluj.ro>
* @author Vitus Szabolcs <szabolcs.vitus1@stud.ubbcluj.ro>
* @date 2025-06-09
*/

#include <pybind11/pybind11.h>
#include <pybind11/stl.h> // For std::vector, std::map, std::string exceptions
#include <pybind11/functional.h> // For lambda binding if needed
#include <sstream> // For stringstream to capture toString output
#include <fstream> // For ofstream to save to file

#include "OpticalSystem.h" // Your OpticalSystem header
#include "OpticalObject.h" // Base class
#include "Lens.h"         // Base for Thin/ThickLens
#include "ThinLens.h"     // Concrete lens types
#include "ThickLens.h"
#include "LightSource.h"     // Concrete object type
#include "Image.h"         // Return type for Calculate

namespace py = pybind11;

/**
 * @brief Binds the C++ `ray` structure and `OpticalSystem` class to Python.
 *
 * This function defines the Python interface for the core `OpticalSystem`
 * class, allowing users to create, manipulate, calculate, and save optical systems.
 * It also exposes the basic `ray` structure.
 *
 * @param m A reference to the pybind11 module to which the classes will be bound.
 */
void bind_optical_system(py::module_ &m) {

    /**
     * @brief Python binding for the `ray` structure.
     *
     * Represents a single ray of light with X and Y coordinates.
     */
    py::class_<ray>(m, "Ray", "Represents a ray of light with X and Y coordinates.")
        .def(py::init<>(), "Initializes a default Ray object.")
        .def_readwrite("x", &ray::x, "The X-coordinate of the ray.")
        .def_readwrite("y", &ray::y, "The Y-coordinate of the ray.");

    /**
     * @brief Python binding for the `OpticalSystem` class.
     *
     * Manages a collection of optical objects (lenses, light sources) and
     * can simulate light propagation through them.
     */
    py::class_<OpticalSystem>(m, "OpticalSystem", "Manages and simulates an optical system.")
        // Constructors
        .def(py::init<>(), "Initializes an empty OpticalSystem.")
        .def(py::init<std::string>(), py::arg("file_name"),
             "Initializes an OpticalSystem by loading from a specified file.")

        // Add methods
        // Overload for adding OpticalObject (Lenses)
        .def("add", static_cast<void(OpticalSystem::*)(OpticalObject&, std::string)>(&OpticalSystem::add),
             py::arg("optical_object"), py::arg("name"),
             "Adds an OpticalObject (e.g., Lens) to the system with a given name.")
        // Overload for adding LightSource
        .def("add", static_cast<void(OpticalSystem::*)(LightSource)>(&OpticalSystem::add),
             py::arg("light_source"),
             "Adds a LightSource to the system.")

        // Modify methods
        .def("modifyLightSource", &OpticalSystem::modifyLightSource,
             py::arg("param"), py::arg("val"),
             "Modifies a parameter of the LightSource (e.g., 'x', 'y').")
        .def("modifyOpticalObject", &OpticalSystem::modifyOpticalObject,
             py::arg("name"), py::arg("param"), py::arg("val"),
             "Modifies a parameter of an OpticalObject by its name (e.g., 'x', 'f', 'n').")

        // Other methods
        .def("getImageSequence", &OpticalSystem::getImageSequence,
             "Retrieves a sequence of images generated by the system.")
        .def("Calculate", &OpticalSystem::Calculate,
             "Calculates and simulates the light propagation through the system, returning the final image.")
        // toString method: Capture ostream output to std::string for Python
        .def("toString", [](OpticalSystem &self) {
            std::stringstream ss;
            self.toString(ss);
            py::print(ss.str()); // Print to Python's stdout
        }, "Prints a string representation of the optical system to standard output.")
        .def("toString", [](OpticalSystem &self, const std::string& file_name) {
            std::ofstream ofs(file_name);
            if (!ofs.is_open()) {
                throw py::cast_error("Failed to open file for writing: " + file_name); // Use py::cast_error for Python exceptions
            }
            self.toString(ofs);
            ofs.close();
        }, py::arg("file_name"), "Writes a string representation of the optical system to a specified file.")
        .def("save", &OpticalSystem::save, py::arg("file_name"),
             "Saves the current state of the optical system to a file.")
        .def("remove", &OpticalSystem::remove, py::arg("name"),
             "Removes an optical object from the system by its name.")
        .def("getSystemElements", &OpticalSystem::getSystemElements,
             "Gets a list of all optical elements (excluding the light source) in the system.")
        .def("getLightSource", &OpticalSystem::getLightSource,
             "Gets the LightSource object currently configured in the system.")
        .def("getRays", &OpticalSystem::getRays,
             "Retrieves the sequence of rays traced through the system.");
}