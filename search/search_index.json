{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introducing the OptiSim!","text":"<p>This comprehensive and versatile geometrical optics simulator brings the fascinating world of light and lenses right to your fingertips. Whether you're a student, educator, researcher, or just curious about how light behaves, our simulator offers an intuitive and powerful platform to explore world of lenses with detail and flexibility.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li> <p>Multi-Platform Accessibility:</p> <ul> <li>C++ Library: Integrate the core simulation engine directly into your high-performance C++ applications.</li> <li>Python Library: Leverage the power and flexibility of Python for scripting, data analysis, and rapid prototyping.</li> <li>Command Line Tool: Run simulations, perform calculations, and generate data effortlessly from your terminal.</li> <li>Intuitive GUI: Visualize ray tracing, manipulate optical elements, and observe results with our user-friendly graphical interface.</li> </ul> </li> <li> <p>Realistic Ray Tracing: Accurately simulate the path of light rays through:</p> <ul> <li>thick lenses</li> <li>thin lenses</li> </ul> </li> <li> <p>Interactive Design &amp; Analysis:</p> <ul> <li>Easy To Use Interface (GUI): Easily assemble complex optical systems by adding their components one by one.</li> <li>Parameter Control: Precisely adjust focal lengths, curvatures, refractive indices, distances, and other properties.</li> <li>Ray Trace Visualization: Observe how changes to your optical system impact ray paths and image formation.</li> </ul> </li> <li> <p>Comprehensive Output:</p> <ul> <li>Generate detailed summary of image formation and ray traces.</li> <li>Export simulation data for further analysis in other tools.</li> </ul> </li> <li> <p>Educational &amp; Research Ready:</p> <ul> <li>Learn by Doing: Ideal for students to grasp fundamental principles of geometrical optics.</li> <li>Experimentation: Conduct virtual experiments and explore \"what-if\" scenarios.</li> <li>Design &amp; Prototype: Aid in the preliminary design and validation of optical systems for research and engineering applications.</li> </ul> </li> </ul> <p>Unlock the power of light with OptiSim! Start exploring, designing, and understanding the intricate beauty of geometrical optics today.</p>"},{"location":"api/","title":"C++ API Reference","text":"<p>This section provides the comprehensive API documentation for the C++ codebase, generated using Doxygen.</p> <p>To explore the detailed class hierarchy, functions, and modules, please click on the link below.</p> <p>Go to C++ Doxygen Documentation</p>"},{"location":"architecture/","title":"Architecture Overview","text":"<p>This document provides a high-level overview of the OptiSim project's architecture, detailing its primary components, their responsibilities, and how they interact. Understanding this structure is key for effective development and contribution.</p>"},{"location":"architecture/#1-high-level-system-design","title":"1. High-Level System Design","text":"<p>OptiSim is designed as a multi-language system, leveraging the strengths of C++ for high-performance computation, Python for scripting and accessibility, and Java for specific enterprise or integration needs. The core logic resides in C++, with Python and Java serving as interfaces and application layers.</p>"},{"location":"architecture/#2-core-components","title":"2. Core Components","text":"<p>The OptiSim system is composed of several distinct, yet interconnected, components:</p>"},{"location":"architecture/#21-c-core-library","title":"2.1. C++ Core Library","text":"<p>This is the foundational layer of OptiSim, responsible for: * Implementing high-performance computational algorithms. * Handling core data structures and complex logic. * Interacting with external, performance-critical C++ libraries (e.g., Eigen for linear algebra, OpenCV for image processing, Boost for extended functionalities).</p> <p>The C++ core is designed for efficiency and precision, forming the bedrock of OptiSim's capabilities.</p>"},{"location":"architecture/#22-python-interface-via-pybind11","title":"2.2. Python Interface (via Pybind11)","text":"<p>The Python layer provides a user-friendly and flexible interface to the powerful C++ core.</p> <ul> <li>Role: Enables Python developers to easily integrate OptiSim's functionalities into their applications, scripts, and data analysis workflows without needing to write C++ code.</li> <li>Technology: <code>pybind11</code> is used to create robust and seamless bindings, exposing C++ classes, functions, and data types directly into Python. This ensures efficient data transfer and method calls between the two languages.</li> </ul>"},{"location":"architecture/#23-java-interface-via-jpype","title":"2.3. Java Interface (via JPype)","text":"<p>The Java layer allows OptiSim's capabilities to be utilized within Java-based applications and ecosystems.</p> <ul> <li>Role: Facilitates integration into existing Java enterprise systems or applications that require OptiSim's specific functionalities.</li> <li>Technology: <code>JPype</code> acts as a bridge, allowing Python code to access Java classes and objects, and vice versa. This enables cross-language communication, where Python might orchestrate calls to Java components that then interact with the C++ core (or directly with other Java libraries).</li> </ul>"},{"location":"architecture/#3-data-flow-and-interoperability","title":"3. Data Flow and Interoperability","text":"<p>Data typically originates from an application layer (Python or Java), is passed to the C++ core for processing, and then results are returned.</p> <ul> <li>Python to C++: Data is passed efficiently through <code>pybind11</code> bindings. Complex data structures are often mapped directly or converted to C++ equivalents.</li> <li>Java to Python: Java can initiate operations by interacting with the Python layer via <code>JPype</code>, which then channels requests to the C++ core. Alternatively, depending on the design, direct integration from Java to C++ might be considered for performance-critical paths if <code>JPype</code> overhead is a concern (though <code>JPype</code> is generally efficient).</li> </ul>"},{"location":"architecture/#4-build-system-overview","title":"4. Build System Overview","text":"<p>The entire project (C++, Python bindings, Java components) is built through a unified, automated shell script. This script orchestrates the build process, which typically involves: * CMake configuration for the C++ parts. * Compilation of C++ source code. * Generation of <code>pybind11</code> Python modules. * Compilation and packaging of Java components.</p> <p>This streamlined approach ensures consistency and simplifies the setup for developers.</p>"},{"location":"architecture/#5-key-design-principles","title":"5. Key Design Principles","text":"<p>OptiSim's architecture is guided by the following principles:</p> <ul> <li>Performance: Critical computation-heavy tasks are offloaded to optimized C++ components.</li> <li>Modularity: Components are designed to be relatively independent, allowing for easier development, testing, and maintenance.</li> <li>Language Agnosticism (Interface Layer): While core logic is in C++, robust interfaces in Python and Java ensure broad applicability and integration flexibility.</li> <li>Extensibility: The design aims to allow for easy addition of new functionalities or interfaces in the future without major architectural overhauls.</li> </ul>"},{"location":"architecture/#6-future-considerations","title":"6. Future Considerations","text":"<p>As OptiSim evolves, potential architectural considerations may include: * Distributed computing capabilities for large-scale simulations. * More direct Java-C++ interfaces if <code>JPype</code> becomes a bottleneck for specific high-frequency operations. * Integration with other language ecosystems as needed. * Expansion of external library dependencies for specialized tasks.</p>"},{"location":"dev_guide/","title":"Developer Guide","text":"<p>This guide is intended for anyone who wishes to contribute to the OptiSim project, build it from source, or understand its internal architecture and development practices. It covers environment setup, build procedures, coding standards, testing, and contribution workflows.</p>"},{"location":"dev_guide/#1-getting-started","title":"1. Getting Started","text":"<p>Before diving into development, ensure you have met all the Requirements specified for developers. This section will guide you through setting up your local development environment.</p>"},{"location":"dev_guide/#11-cloning-the-repository","title":"1.1. Cloning the Repository","text":"<p>To begin, obtain the OptiSim source code from its Git repository.</p>"},{"location":"dev_guide/#12-setting-up-the-python-virtual-environment","title":"1.2. Setting Up the Python Virtual Environment","text":"<p>Working within a Python virtual environment is crucial to manage dependencies and avoid conflicts with your system's Python installation. This involves creating the environment, activating it, and then installing all necessary Python packages.</p>"},{"location":"dev_guide/#2-building-the-project","title":"2. Building the Project","text":"<p>The entire build process for OptiSim's C++ backend and Python bindings is automated via a dedicated shell script.</p>"},{"location":"dev_guide/#21-standard-build-process","title":"2.1. Standard Build Process","text":"<p>To build the project, navigate to the project root directory and execute the provided build script. This script handles all necessary steps, including CMake configuration, compilation of the C++ components, and generation of the Python module.</p>"},{"location":"dev_guide/#22-building-the-python-module","title":"2.2. Building the Python Module","text":"<p>The Python module (e.g., <code>optisim.cpython-312-x86_64-linux-gnu.so</code>) is compiled and prepared for use as part of the automated build script. Ensure it is placed in a directory accessible by Python's import mechanism.</p>"},{"location":"dev_guide/#3-project-structure","title":"3. Project Structure","text":"<p>Understanding the project's directory layout is essential for navigation and contribution.</p> <ul> <li><code>/</code> (Project Root): Contains main configuration files such as <code>CMakeLists.txt</code>, <code>mkdocs.yml</code>, and the primary documentation folder.</li> <li><code>/CPP/</code>: (Or <code>/src/</code>, <code>/core/</code> etc.) Source code for the core C++ OptiSim library.</li> <li><code>/Python/</code>: Python-specific code, <code>pybind11</code> binding definitions, and potentially pure Python modules that interface with the C++ backend.</li> <li><code>/Java/</code>: (If applicable) Java source code, along with relevant build configuration files.</li> <li><code>/docs/</code>: Contains the MkDocs documentation source files, including this guide.</li> <li><code>/tests/</code>: Unit and integration tests for both C++ and Python components.</li> <li><code>/Run/</code>: Contains the shell file necessary for compilation.</li> <li><code>/examples/</code>: Python and CPP example files and basic applications.  </li> </ul>"},{"location":"dev_guide/#4-coding-guidelines-and-style","title":"4. Coding Guidelines and Style","text":"<p>Maintaining a consistent code style is vital for readability and collaboration.</p>"},{"location":"dev_guide/#41-c-coding-style","title":"4.1. C++ Coding Style","text":"<ul> <li>Follow the Google C++ Style Guide </li> </ul>"},{"location":"dev_guide/#42-python-coding-style","title":"4.2. Python Coding Style","text":"<ul> <li>Adhere to PEP 8 for Python code.</li> </ul>"},{"location":"dev_guide/#43-java-coding-style","title":"4.3. Java Coding Style","text":"<ul> <li>Follow the Google Java Style Guide </li> </ul>"},{"location":"dev_guide/#44-documentation-style","title":"4.4. Documentation Style","text":"<ul> <li>C++: Use Doxygen style comments for C++ code.</li> <li>Python: Use NumPy style docstrings for all Python functions, classes, and modules, as configured in <code>mkdocstrings</code>.</li> </ul>"},{"location":"dev_guide/#5-documentation","title":"5. Documentation","text":"<p>Well-maintained documentation is crucial for user adoption and developer collaboration.</p>"},{"location":"dev_guide/#51-building-local-documentation","title":"5.1. Building Local Documentation","text":"<p>To build the project website locally, use MkDocs. This typically starts a local development server, allowing you to preview changes.</p>"},{"location":"dev_guide/#52-contributing-to-documentation","title":"5.2. Contributing to Documentation","text":"<ul> <li>Website Content: Modifications to the project's website content are made by editing Markdown files within the <code>/docs/</code> directory.</li> <li>Python API Docs: Updates to Python API documentation are achieved by modifying docstrings directly within the Python code (or <code>pybind11</code> C++ files). These are automatically rendered by <code>mkdocstrings</code>.</li> <li>C++ API Docs: C++ API documentation is updated by adding or modifying Doxygen comments in the C++ header and source files.</li> </ul>"},{"location":"dev_guide/#53-generating-c-doxygen-documentation","title":"5.3. Generating C++ Doxygen Documentation","text":"<p>Standalone C++ API documentation can be generated using Doxygen, provided a <code>Doxyfile</code> is correctly configured for your C++ source code.</p>"},{"location":"dev_guide/#6-contribution-workflow","title":"6. Contribution Workflow","text":"<p>We welcome contributions and encourage developers to follow these guidelines:</p> <ol> <li>Fork the Repository: Create a personal fork of the OptiSim repository on the chosen Git platform.</li> <li>Create a Feature Branch: For each new feature or bug fix, create a new branch from the main development branch (e.g., <code>main</code> or <code>develop</code>).</li> <li>Implement Changes: Develop your code, ensuring adherence to the project's Coding Guidelines and proper testing.</li> <li>Test Your Changes: Thoroughly run relevant unit and integration tests to validate your modifications.</li> <li>Document Your Changes: Update docstrings, inline comments, and relevant sections of user or developer guides to reflect your changes.</li> <li>Commit Your Changes: Provide clear, concise, and descriptive commit messages.</li> <li>Push Your Branch: Upload your local feature branch to your forked repository.</li> <li>Create a Pull Request (PR): Open a pull request from your branch to the main development branch of the central repository. Include a detailed description of your changes and reference any associated issues.</li> <li>Address Feedback: Actively participate in the code review process, addressing comments and making requested adjustments.</li> </ol>"},{"location":"dev_guide/#7-logging","title":"7. Logging","text":"<ul> <li>Logging: Implement comprehensive logging mechanisms in both C++ and Python components to assist in tracing execution flow and identifying issues.</li> </ul>"},{"location":"examples/","title":"Examples","text":"<p>Dive into practical applications of the OptiSim with these illustrative examples. Whether you prefer C++, Python, or command line tools, we've got you covered. These examples demonstrate basic system creation, manipulation, and analysis.</p>"},{"location":"examples/#c-example","title":"C++ Example","text":"<p>Our C++ library offers powerful capabilities for building and simulating optical systems directly within your applications. This example showcases how to create a simple system, add components, perform calculations, and even load/save systems from JSON files.</p> <pre><code>#include &lt;iostream&gt;\n#include \"OptiSim.h\"\n\nusing namespace std;\n\nint main(){\n    //create new empty system\n    OpticalSystem my_system;\n\n    //create new LightSource at x = 0 and height = 8\n    LightSource LS(0, 8);\n\n    //add light source to system\n    my_system.add(LS);\n\n    //create new thin lens at x = 20 with f = 10\n    ThinLens L1(20, 10);\n\n    //add Light thin lens to system\n    my_system.add(L1, \"Lens_1\");\n\n    //calculate image formation\n    my_system.Calculate();\n\n    //print informations about system and image formation\n    my_system.toString();\n\n    // ------------------------------------------------------------------------\n    //create new system from jason\n    OpticalSystem my_second_system(\"./json_files/presentation2.json\");\n\n    //calculate image formation\n    my_second_system.Calculate();\n\n    //print informations about system and image formation\n    my_second_system.toString();\n\n    //remove a lens\n    my_second_system.remove(\"Lens_1\");\n\n    //recalculate image formation\n    my_second_system.Calculate();\n\n    //pritn information about system and image formation\n    my_second_system.toString();\n\n    //saved modified system\n    my_second_system.save(\"./json_files/presentaion2_modified.json\");\n\n    return 0;\n}\n</code></pre>"},{"location":"examples/#python-example","title":"Python Example","text":"<p>Leverage the OptiSim Python library for rapid prototyping, scripting, and integrating optical simulations into your data science workflows. This example mirrors the C++ functionality, demonstrating the ease of use in Python.</p> <pre><code>import optisim as op\n\n# create new empty system\nmy_system = op.OpticalSystem()\n\n# create new light source at x = 0 and height = 8\nLS = op.LightSource(0, 8)\n\n# add light source to system\nmy_system.add(LS)\n\n# create new thin lens at x = 20 with f = 10\nL1 = op.ThinLens(20, 10)\n\n# add light source to system\nmy_system.add(L1, \"Lens_1\")\n\n# calculate image formation\nmy_system.Calculate()\n\n# print informations about system and image formation\nmy_system.toString()\n\n#-----------------------------------------------------\n# create new system from json\nmy_second_system = op.OpticalSystem(\"./json_files/presentation2.json\")\n\n# calculate image formation\nmy_second_system.Calculate()\n\n# print informations about system and image formation\nmy_second_system.toString()\n\n# remove a lens\nmy_second_system.remove(\"Lens_1\")\n\n# recalculate the image formation\nmy_second_system.Calculate()\n\n# print informations about system and image formation\nmy_second_system.toString()\n\nmy_second_system.save(\"./json_files/presentation2_modified.json\")\n\n\n\n\n\n</code></pre>"},{"location":"examples/#json-configuration-example","title":"JSON Configuration Example","text":"<p>For quick setup or defining complex optical systems, you can use JSON files. This example shows a presentation2.json file used in the C++ and Python examples above, demonstrating how to define an object and multiple thin and thick lenses.</p> <pre><code>{\n  \"lenses\": [\n    {\n      \"focal_length\": 5.0,\n      \"name\": \"Lens_1\",\n      \"position\": 10.0,\n      \"type\": \"thin\"\n    },\n    {\n      \"focal_length\": -10.0,\n      \"name\": \"Lens_3\",\n      \"position\": 15.0,\n      \"type\": \"thin\"\n    },\n    {\n      \"name\": \"Lens_4\",\n      \"position\": 40.0,\n      \"radius_left\": 15.0,\n      \"radius_right\": -20.0,\n      \"refractive_index\": 1.52,\n      \"thickness\": 4.0,\n      \"type\": \"thick\"\n    },\n    {\n      \"name\": \"Lens_5\",\n      \"position\": 55.0,\n      \"radius_left\": 17.0,\n      \"radius_right\": -20.0,\n      \"refractive_index\": 1.72,\n      \"thickness\": 4.5,\n      \"type\": \"thick\"\n    },\n    {\n      \"name\": \"Lens_2\",\n      \"position\": 60.0,\n      \"radius_left\": 12.0,\n      \"radius_right\": -21.0,\n      \"refractive_index\": 1.52,\n      \"thickness\": 3.5,\n      \"type\": \"thick\"\n    }\n  ],\n  \"object\": {\n    \"position\": 0.0,\n    \"size\": 1.5\n  }\n}\n</code></pre>"},{"location":"examples/#command-line-interface-cli-example","title":"Command Line Interface (CLI) Example","text":"<p>The OptiSim command-line tool provides a powerful way to run simulations and manage optical systems directly from your terminal. You can specify input/output files, print system details, and control the level of output detail.</p> <p>To see the available options, simply run the tool with the --help flag:</p> <pre><code>$ ./OptiSim --help\n-------------------------------------------------------------------------------\n###    OptiSim - tool for simulating geometrical optics\n-------------------------------------------------------------------------------\n\nDescription: By default, this tool reads an optical system from a file called \"input.json\" and writes the calculation results to a file called \"output.txt\".\nUsage: OptiSim [OPTIONS]\n\nOption             Long option           Meaning\n-h                 --help                Show this help text and exit.\n-i=&lt;json-file&gt;     --input=&lt;json-file&gt;   Specify the file from which to read the system.\n-il                --imagelist           Expands the output with the image list.\n-o=&lt;file&gt;          --output=&lt;file&gt;       Specify the file in which to save the output.\n-p                 --print               Print the parameters of the optical system to the console.\n-r                 --rays                Expands the output with the ray coordinates.\n-v                 --version             Print version info.\n</code></pre> <p>Here's an example of how you might use the command-line tool to load a system from <code>presentation2.json</code>, print its parameters to the console, and save the detailed image list and ray coordinates to <code>my_simulation_results.txt</code>:</p> <pre><code>$ ./OptiSim --input=./json_files/presentation2.json --print --imagelist --rays --output=my_simulation_results.txt\n</code></pre> <p>This command will:</p> <ul> <li>Read the optical system definition from <code>./json_files/presentation2.json</code>.</li> <li>Print a summary of the system's parameters directly to your terminal.</li> <li>Calculate the image formation and include a detailed list of images and ray coordinates in the output.</li> <li>Save the complete results to <code>my_simulation_results.txt</code>.</li> </ul>"},{"location":"examples/#example-output","title":"Example Output","text":"<p>When you run the command above, the <code>my_simulation_results.txt</code> file  will generate a detailed summary of the optical system, including image formation and ray coordinates. Here's what a typical output looks like:</p> <pre><code>-------------------------------------------------------------------------------\n#    SYSTEM SUMMARY\n-------------------------------------------------------------------------------\nObject Position: 0, Size: 1.5\n\nThin Lens: Lens_1,   Position: 10, Focal Length: 5\n\nThin Lens: Lens_3,   Position: 15, Focal Length: -10\n\nThick Lens: Lens_4, Position: 40, n: 1.52, Thickness: 4, Radius_left: 15, Radius_right: -20, Focal Length: 17.1542\n\nThick Lens: Lens_5, Position: 55, n: 1.72, Thickness: 4.5, Radius_left: 17, Radius_right: -20, Focal Length: 13.4474\n\nThick Lens: Lens_2, Position: 60, n: 1.52, Thickness: 3.5, Radius_left: 12, Radius_right: -21, Focal Length: 15.2382\n\nImage Position: 67.0362, Size: 1.5723, Is real: 1\n-------------------------------------------------------------------------------\n#    Images\n-------------------------------------------------------------------------------\nX coordinate   Y coordinate   Is real?\n\n   20.000000       -1.500000         1\n   25.000000       -3.000000         1\n  -41.141484      -17.266449         0\n   71.420402        2.841596         1\n   67.036177        1.572302         1\n\n-------------------------------------------------------------------------------\n#    Rays\n-------------------------------------------------------------------------------\n             Ray 1                       Ray 2\n\nX coordinate   Y coordinate   X coordinate   Y coordinate \n\n    0.000000       1.500000       0.000000       1.500000\n   10.000000       1.500000      10.000000       0.000000\n   15.000000       0.000000      15.000000      -0.750000\n   40.000000      -7.500000      40.000000      -6.375000\n   55.000000      -5.694552      55.000000      -4.361582\n   60.000000      -3.095302      60.000000      -2.168220\n   67.036177       1.572302      67.036177       1.572302\n\n-------------------------------------------------------------------------------\n</code></pre> <p>These examples provide a starting point. Feel free to modify them and experiment with different optical components and configurations.</p>"},{"location":"install/","title":"OptiSim Installation Guide","text":"<p>Welcome to OptiSim \u2013 a modular optical simulator with C++, Python, and Java components. This guide will walk you through setting up the application and using it as a GUI program or as a library in your own projects.</p>"},{"location":"install/#prerequisites","title":"Prerequisites","text":"<p>Before you get started, make sure you have the following installed:</p> <ul> <li>CMake and g++</li> <li>Python 3.12 or later</li> <li>Java Development Kit (JDK)</li> <li>A Linux-based OS (tested on Ubuntu)</li> <li>pybind11 and jpype </li> </ul>"},{"location":"install/#step-1-clone-the-repository","title":"Step 1: Clone the Repository","text":"<p>Clone the OptiSim repository from GitHub:</p> <pre><code>git clone https://github.com/VitusSzabolcs/OptiSim.git\n</code></pre>"},{"location":"install/#step-2-navigate-to-the-installer","title":"Step 2: Navigate to the Installer","text":"<p>Change directory to the OptiSim installer:</p> <pre><code>cd OptiSim/Run\n</code></pre>"},{"location":"install/#step-3-compile-and-install","title":"Step 3: Compile and Install","text":"<p>Run the installation script:</p> <pre><code>./run.sh\n</code></pre> <p>This script will: - Compile all necessary components (C++, Python, Java)</p> <ul> <li> <p>Add the CLI build directory to your PATH so you can run OptiSim from any terminal</p> </li> <li> <p>Create a desktop shortcut for launching the GUI version</p> </li> </ul> <p>NOTE: If the script doesn't launch via double-click, ensure it's executable and trusted, or run it from a terminal.</p>"},{"location":"install/#using-optisim-as-a-c-library","title":"Using OptiSim as a C++ Library","text":"<p>You can integrate OptiSim into your own C++ programs.</p>"},{"location":"install/#include-the-header","title":"Include the Header","text":"<pre><code>#include \"OptiSim.h\"\n</code></pre>"},{"location":"install/#compile-your-program","title":"Compile Your Program","text":"<p>Replace <code>&lt;full-path-to-OptiSim&gt;</code> with the actual path to your cloned repository:</p> <pre><code>g++ your_program.cpp \\\n  -I&lt;full-path-to-OptiSim&gt;/CPP/include \\\n  -L&lt;full-path-to-OptiSim&gt;/CPP/build \\\n  -lOptiSimLib \\\n  -o example\n</code></pre>"},{"location":"install/#using-optisim-as-a-python-module","title":"Using OptiSim as a Python Module","text":"<p>To use OptiSim in Python:</p> <ol> <li>Copy the compiled shared object file to your working directory:</li> </ol> <pre><code>cp &lt;full-path-to-OptiSim&gt;/Python/optisim.cpython-312-x86_64-linux-gnu.so .\n</code></pre> <ol> <li>Import it in Python:</li> </ol> <pre><code>import optisim\n</code></pre> <p>You can now access the OptiSim functionality directly in Python scripts or Jupyter notebooks.</p>"},{"location":"install/#gui-application","title":"GUI Application","text":"<p>Once the installation completes:</p> <ul> <li> <p>A desktop shortcut named \"OptiSim\" will appear on your desktop.</p> </li> <li> <p>Double-click it to launch the GUI application.</p> </li> </ul>"},{"location":"install/#need-help","title":"Need Help?","text":"<p>If you run into any issues during installation or usage, feel free to open an issue on the GitHub repository.</p>"},{"location":"python_api/","title":"Python API Reference","text":"<p>This page provides auto-generated documentation for the <code>optisim</code> Python module, which serves as the interface to the high-performance C++ OptiSim library.</p> <p>All classes and functions exposed from the C++ backend via <code>pybind11</code> are detailed below, including their methods, properties, and constructors.</p> <p>OptiSim: A C++ Optical Simulation Library bound to Python using pybind11.</p>"},{"location":"python_api/#optisim-attributes","title":"Attributes","text":""},{"location":"python_api/#optisim.__doc__","title":"__doc__  <code>module</code>","text":"<pre><code>__doc__ = 'OptiSim: A C++ Optical Simulation Library bound to Python using pybind11.'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.</p>"},{"location":"python_api/#optisim.__name__","title":"__name__  <code>module</code>","text":"<pre><code>__name__ = 'optisim'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.</p>"},{"location":"python_api/#optisim-classes","title":"Classes","text":""},{"location":"python_api/#optisim.Image","title":"Image","text":"<p>               Bases: <code>optisim.ImagingSubject</code></p> <p>Represents an image (real or virtual) in the simulation.</p>"},{"location":"python_api/#optisim.Image-attributes","title":"Attributes","text":""},{"location":"python_api/#optisim.Image.__doc__","title":"__doc__  <code>class</code>","text":"<pre><code>__doc__ = 'Represents an image (real or virtual) in the simulation.'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.</p>"},{"location":"python_api/#optisim.Image.__module__","title":"__module__  <code>class</code>","text":"<pre><code>__module__ = 'optisim'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.</p>"},{"location":"python_api/#optisim.Image-functions","title":"Functions","text":""},{"location":"python_api/#optisim.Image.__init__","title":"__init__  <code>method descriptor</code>","text":"<pre><code>__init__()\n</code></pre> <p>init(self: optisim.Image, x: float, y: float, is_real: bool) -&gt; None</p> <p>Initializes an Image with specified X, Y coordinates, and real/virtual status.</p>"},{"location":"python_api/#optisim.Image.getReal","title":"getReal  <code>method descriptor</code>","text":"<pre><code>getReal()\n</code></pre> <p>getReal(self: optisim.Image) -&gt; bool</p> <p>Checks if the image is real (True) or virtual (False).</p>"},{"location":"python_api/#optisim.Image.setReal","title":"setReal  <code>method descriptor</code>","text":"<pre><code>setReal()\n</code></pre> <p>setReal(self: optisim.Image, arg0: bool) -&gt; None</p> <p>Sets the real/virtual status of the image.</p>"},{"location":"python_api/#optisim.ImagingSubject","title":"ImagingSubject","text":"<p>               Bases: <code>pybind11_builtins.pybind11_object</code></p> <p>Abstract base class for all imaging subjects with X and Y coordinates.</p>"},{"location":"python_api/#optisim.ImagingSubject-attributes","title":"Attributes","text":""},{"location":"python_api/#optisim.ImagingSubject.__doc__","title":"__doc__  <code>class</code>","text":"<pre><code>__doc__ = 'Abstract base class for all imaging subjects with X and Y coordinates.'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.</p>"},{"location":"python_api/#optisim.ImagingSubject.__module__","title":"__module__  <code>class</code>","text":"<pre><code>__module__ = 'optisim'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.</p>"},{"location":"python_api/#optisim.ImagingSubject-functions","title":"Functions","text":""},{"location":"python_api/#optisim.ImagingSubject.__init__","title":"__init__  <code>method descriptor</code>","text":"<pre><code>__init__(*args, **kwargs)\n</code></pre> <p>Initialize self.  See help(type(self)) for accurate signature.</p>"},{"location":"python_api/#optisim.ImagingSubject.getX","title":"getX  <code>method descriptor</code>","text":"<pre><code>getX()\n</code></pre> <p>getX(self: optisim.ImagingSubject) -&gt; float</p> <p>Gets the X-coordinate of the subject.</p>"},{"location":"python_api/#optisim.ImagingSubject.getY","title":"getY  <code>method descriptor</code>","text":"<pre><code>getY()\n</code></pre> <p>getY(self: optisim.ImagingSubject) -&gt; float</p> <p>Gets the Y-coordinate of the subject.</p>"},{"location":"python_api/#optisim.ImagingSubject.setX","title":"setX  <code>method descriptor</code>","text":"<pre><code>setX()\n</code></pre> <p>setX(self: optisim.ImagingSubject, arg0: float) -&gt; None</p> <p>Sets the X-coordinate of the subject.</p>"},{"location":"python_api/#optisim.ImagingSubject.setY","title":"setY  <code>method descriptor</code>","text":"<pre><code>setY()\n</code></pre> <p>setY(self: optisim.ImagingSubject, arg0: float) -&gt; None</p> <p>Sets the Y-coordinate of the subject.</p>"},{"location":"python_api/#optisim.Lens","title":"Lens","text":"<p>               Bases: <code>optisim.OpticalObject</code></p> <p>Abstract base class for all lens types.</p>"},{"location":"python_api/#optisim.Lens-attributes","title":"Attributes","text":""},{"location":"python_api/#optisim.Lens.__doc__","title":"__doc__  <code>class</code>","text":"<pre><code>__doc__ = 'Abstract base class for all lens types.'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.</p>"},{"location":"python_api/#optisim.Lens.__module__","title":"__module__  <code>class</code>","text":"<pre><code>__module__ = 'optisim'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.</p>"},{"location":"python_api/#optisim.Lens-functions","title":"Functions","text":""},{"location":"python_api/#optisim.Lens.__init__","title":"__init__  <code>method descriptor</code>","text":"<pre><code>__init__(*args, **kwargs)\n</code></pre> <p>Initialize self.  See help(type(self)) for accurate signature.</p>"},{"location":"python_api/#optisim.Lens.getF","title":"getF  <code>method descriptor</code>","text":"<pre><code>getF()\n</code></pre> <p>getF(self: optisim.Lens) -&gt; float</p> <p>Gets the focal length of the lens.</p>"},{"location":"python_api/#optisim.LightSource","title":"LightSource","text":"<p>               Bases: <code>optisim.ImagingSubject</code></p> <p>Represents a point light source in the simulation.</p>"},{"location":"python_api/#optisim.LightSource-attributes","title":"Attributes","text":""},{"location":"python_api/#optisim.LightSource.__doc__","title":"__doc__  <code>class</code>","text":"<pre><code>__doc__ = 'Represents a point light source in the simulation.'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.</p>"},{"location":"python_api/#optisim.LightSource.__module__","title":"__module__  <code>class</code>","text":"<pre><code>__module__ = 'optisim'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.</p>"},{"location":"python_api/#optisim.LightSource-functions","title":"Functions","text":""},{"location":"python_api/#optisim.LightSource.__init__","title":"__init__  <code>method descriptor</code>","text":"<pre><code>__init__()\n</code></pre> <p>init(self: optisim.LightSource, x: float, y: float) -&gt; None</p> <p>Initializes a LightSource with specified X and Y coordinates.</p>"},{"location":"python_api/#optisim.OptiSimError","title":"OptiSimError","text":"<p>               Bases: <code>builtins.Exception</code></p>"},{"location":"python_api/#optisim.OptiSimError-attributes","title":"Attributes","text":""},{"location":"python_api/#optisim.OptiSimError.__module__","title":"__module__  <code>class</code>","text":"<pre><code>__module__ = 'optisim'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.</p>"},{"location":"python_api/#optisim.OptiSimError.__weakref__","title":"__weakref__  <code>property</code>","text":"<pre><code>__weakref__\n</code></pre> <p>list of weak references to the object</p>"},{"location":"python_api/#optisim.OpticalObject","title":"OpticalObject","text":"<p>               Bases: <code>pybind11_builtins.pybind11_object</code></p> <p>Abstract base class for all optical components.</p>"},{"location":"python_api/#optisim.OpticalObject-attributes","title":"Attributes","text":""},{"location":"python_api/#optisim.OpticalObject.__doc__","title":"__doc__  <code>class</code>","text":"<pre><code>__doc__ = 'Abstract base class for all optical components.'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.</p>"},{"location":"python_api/#optisim.OpticalObject.__module__","title":"__module__  <code>class</code>","text":"<pre><code>__module__ = 'optisim'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.</p>"},{"location":"python_api/#optisim.OpticalObject-functions","title":"Functions","text":""},{"location":"python_api/#optisim.OpticalObject.__init__","title":"__init__  <code>method descriptor</code>","text":"<pre><code>__init__(*args, **kwargs)\n</code></pre> <p>Initialize self.  See help(type(self)) for accurate signature.</p>"},{"location":"python_api/#optisim.OpticalObject.getX","title":"getX  <code>method descriptor</code>","text":"<pre><code>getX()\n</code></pre> <p>getX(self: optisim.OpticalObject) -&gt; float</p> <p>Gets the X-coordinate (position along the optical axis) of the object.</p>"},{"location":"python_api/#optisim.OpticalObject.setX","title":"setX  <code>method descriptor</code>","text":"<pre><code>setX()\n</code></pre> <p>setX(self: optisim.OpticalObject, x: float) -&gt; None</p> <p>Sets the X-coordinate (position along the optical axis) of the object.</p>"},{"location":"python_api/#optisim.OpticalSystem","title":"OpticalSystem","text":"<p>               Bases: <code>pybind11_builtins.pybind11_object</code></p> <p>Manages and simulates an optical system.</p>"},{"location":"python_api/#optisim.OpticalSystem-attributes","title":"Attributes","text":""},{"location":"python_api/#optisim.OpticalSystem.__doc__","title":"__doc__  <code>class</code>","text":"<pre><code>__doc__ = 'Manages and simulates an optical system.'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.</p>"},{"location":"python_api/#optisim.OpticalSystem.__module__","title":"__module__  <code>class</code>","text":"<pre><code>__module__ = 'optisim'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.</p>"},{"location":"python_api/#optisim.OpticalSystem-functions","title":"Functions","text":""},{"location":"python_api/#optisim.OpticalSystem.Calculate","title":"Calculate  <code>method descriptor</code>","text":"<pre><code>Calculate()\n</code></pre> <p>Calculate(self: optisim.OpticalSystem) -&gt; optisim.Image</p> <p>Calculates and simulates the light propagation through the system, returning the final image.</p>"},{"location":"python_api/#optisim.OpticalSystem.__init__","title":"__init__  <code>method descriptor</code>","text":"<pre><code>__init__()\n</code></pre> <p>init(args, *kwargs) Overloaded function.</p> <ol> <li>init(self: optisim.OpticalSystem) -&gt; None</li> </ol> <p>Initializes an empty OpticalSystem.</p> <ol> <li>init(self: optisim.OpticalSystem, file_name: str) -&gt; None</li> </ol> <p>Initializes an OpticalSystem by loading from a specified file.</p>"},{"location":"python_api/#optisim.OpticalSystem.add","title":"add  <code>method descriptor</code>","text":"<pre><code>add()\n</code></pre> <p>add(args, *kwargs) Overloaded function.</p> <ol> <li>add(self: optisim.OpticalSystem, optical_object: optisim.OpticalObject, name: str) -&gt; None</li> </ol> <p>Adds an OpticalObject (e.g., Lens) to the system with a given name.</p> <ol> <li>add(self: optisim.OpticalSystem, light_source: optisim.LightSource) -&gt; None</li> </ol> <p>Adds a LightSource to the system.</p>"},{"location":"python_api/#optisim.OpticalSystem.getImageSequence","title":"getImageSequence  <code>method descriptor</code>","text":"<pre><code>getImageSequence()\n</code></pre> <p>getImageSequence(self: optisim.OpticalSystem) -&gt; list[optisim.Image]</p> <p>Retrieves a sequence of images generated by the system.</p>"},{"location":"python_api/#optisim.OpticalSystem.getLightSource","title":"getLightSource  <code>method descriptor</code>","text":"<pre><code>getLightSource()\n</code></pre> <p>getLightSource(self: optisim.OpticalSystem) -&gt; optisim.LightSource</p> <p>Gets the LightSource object currently configured in the system.</p>"},{"location":"python_api/#optisim.OpticalSystem.getRays","title":"getRays  <code>method descriptor</code>","text":"<pre><code>getRays()\n</code></pre> <p>getRays(self: optisim.OpticalSystem) -&gt; dict[str, optisim.Ray]</p> <p>Retrieves the sequence of rays traced through the system.</p>"},{"location":"python_api/#optisim.OpticalSystem.getSystemElements","title":"getSystemElements  <code>method descriptor</code>","text":"<pre><code>getSystemElements()\n</code></pre> <p>getSystemElements(self: optisim.OpticalSystem) -&gt; dict[str, optisim.OpticalObject]</p> <p>Gets a list of all optical elements (excluding the light source) in the system.</p>"},{"location":"python_api/#optisim.OpticalSystem.modifyLightSource","title":"modifyLightSource  <code>method descriptor</code>","text":"<pre><code>modifyLightSource()\n</code></pre> <p>modifyLightSource(self: optisim.OpticalSystem, param: str, val: float) -&gt; None</p> <p>Modifies a parameter of the LightSource (e.g., 'x', 'y').</p>"},{"location":"python_api/#optisim.OpticalSystem.modifyOpticalObject","title":"modifyOpticalObject  <code>method descriptor</code>","text":"<pre><code>modifyOpticalObject()\n</code></pre> <p>modifyOpticalObject(self: optisim.OpticalSystem, name: str, param: str, val: float) -&gt; None</p> <p>Modifies a parameter of an OpticalObject by its name (e.g., 'x', 'f', 'n').</p>"},{"location":"python_api/#optisim.OpticalSystem.remove","title":"remove  <code>method descriptor</code>","text":"<pre><code>remove()\n</code></pre> <p>remove(self: optisim.OpticalSystem, name: str) -&gt; None</p> <p>Removes an optical object from the system by its name.</p>"},{"location":"python_api/#optisim.OpticalSystem.save","title":"save  <code>method descriptor</code>","text":"<pre><code>save()\n</code></pre> <p>save(self: optisim.OpticalSystem, file_name: str) -&gt; None</p> <p>Saves the current state of the optical system to a file.</p>"},{"location":"python_api/#optisim.OpticalSystem.toString","title":"toString  <code>method descriptor</code>","text":"<pre><code>toString()\n</code></pre> <p>toString(args, *kwargs) Overloaded function.</p> <ol> <li>toString(self: optisim.OpticalSystem) -&gt; None</li> </ol> <p>Prints a string representation of the optical system to standard output.</p> <ol> <li>toString(self: optisim.OpticalSystem, file_name: str) -&gt; None</li> </ol> <p>Writes a string representation of the optical system to a specified file.</p>"},{"location":"python_api/#optisim.Ray","title":"Ray","text":"<p>               Bases: <code>pybind11_builtins.pybind11_object</code></p> <p>Represents a ray of light with X and Y coordinates.</p>"},{"location":"python_api/#optisim.Ray-attributes","title":"Attributes","text":""},{"location":"python_api/#optisim.Ray.__doc__","title":"__doc__  <code>class</code>","text":"<pre><code>__doc__ = 'Represents a ray of light with X and Y coordinates.'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.</p>"},{"location":"python_api/#optisim.Ray.__module__","title":"__module__  <code>class</code>","text":"<pre><code>__module__ = 'optisim'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.</p>"},{"location":"python_api/#optisim.Ray.x","title":"x  <code>property</code>","text":"<pre><code>x\n</code></pre> <p>The X-coordinate of the ray.</p>"},{"location":"python_api/#optisim.Ray.y","title":"y  <code>property</code>","text":"<pre><code>y\n</code></pre> <p>The Y-coordinate of the ray.</p>"},{"location":"python_api/#optisim.Ray-functions","title":"Functions","text":""},{"location":"python_api/#optisim.Ray.__init__","title":"__init__  <code>method descriptor</code>","text":"<pre><code>__init__()\n</code></pre> <p>init(self: optisim.Ray) -&gt; None</p> <p>Initializes a default Ray object.</p>"},{"location":"python_api/#optisim.ThickLens","title":"ThickLens","text":"<p>               Bases: <code>optisim.Lens</code></p> <p>Represents a thick lens with two curved surfaces and finite thickness.</p>"},{"location":"python_api/#optisim.ThickLens-attributes","title":"Attributes","text":""},{"location":"python_api/#optisim.ThickLens.__doc__","title":"__doc__  <code>class</code>","text":"<pre><code>__doc__ = 'Represents a thick lens with two curved surfaces and finite thickness.'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.</p>"},{"location":"python_api/#optisim.ThickLens.__module__","title":"__module__  <code>class</code>","text":"<pre><code>__module__ = 'optisim'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.</p>"},{"location":"python_api/#optisim.ThickLens-functions","title":"Functions","text":""},{"location":"python_api/#optisim.ThickLens.Calculate","title":"Calculate  <code>method descriptor</code>","text":"<pre><code>Calculate()\n</code></pre> <p>Calculate(self: optisim.ThickLens, imaging_subject: ImagingSubject) -&gt; Image</p> <p>Calculates the image formed by the thick lens for a given imaging subject.</p>"},{"location":"python_api/#optisim.ThickLens.__init__","title":"__init__  <code>method descriptor</code>","text":"<pre><code>__init__()\n</code></pre> <p>init(self: optisim.ThickLens, x: float, n: float, d: float, r_left: float, r_right: float) -&gt; None</p> <p>Initializes a ThickLens with X-coordinate, refractive index, thickness, and radii of curvature.</p>"},{"location":"python_api/#optisim.ThickLens.getD","title":"getD  <code>method descriptor</code>","text":"<pre><code>getD()\n</code></pre> <p>getD(self: optisim.ThickLens) -&gt; float</p> <p>Gets the thickness of the lens along the optical axis.</p>"},{"location":"python_api/#optisim.ThickLens.getN","title":"getN  <code>method descriptor</code>","text":"<pre><code>getN()\n</code></pre> <p>getN(self: optisim.ThickLens) -&gt; float</p> <p>Gets the refractive index of the lens material.</p>"},{"location":"python_api/#optisim.ThickLens.getR_left","title":"getR_left  <code>method descriptor</code>","text":"<pre><code>getR_left()\n</code></pre> <p>getR_left(self: optisim.ThickLens) -&gt; float</p> <p>Gets the radius of curvature of the left surface.</p>"},{"location":"python_api/#optisim.ThickLens.getR_right","title":"getR_right  <code>method descriptor</code>","text":"<pre><code>getR_right()\n</code></pre> <p>getR_right(self: optisim.ThickLens) -&gt; float</p> <p>Gets the radius of curvature of the right surface.</p>"},{"location":"python_api/#optisim.ThickLens.setD","title":"setD  <code>method descriptor</code>","text":"<pre><code>setD()\n</code></pre> <p>setD(self: optisim.ThickLens, d: float) -&gt; None</p> <p>Sets the thickness of the lens along the optical axis.</p>"},{"location":"python_api/#optisim.ThickLens.setN","title":"setN  <code>method descriptor</code>","text":"<pre><code>setN()\n</code></pre> <p>setN(self: optisim.ThickLens, n: float) -&gt; None</p> <p>Sets the refractive index of the lens material.</p>"},{"location":"python_api/#optisim.ThickLens.setR_left","title":"setR_left  <code>method descriptor</code>","text":"<pre><code>setR_left()\n</code></pre> <p>setR_left(self: optisim.ThickLens, r_left: float) -&gt; None</p> <p>Sets the radius of curvature of the left surface.</p>"},{"location":"python_api/#optisim.ThickLens.setR_right","title":"setR_right  <code>method descriptor</code>","text":"<pre><code>setR_right()\n</code></pre> <p>setR_right(self: optisim.ThickLens, r_right: float) -&gt; None</p> <p>Sets the radius of curvature of the right surface.</p>"},{"location":"python_api/#optisim.ThinLens","title":"ThinLens","text":"<p>               Bases: <code>optisim.Lens</code></p> <p>Represents an idealized thin lens.</p>"},{"location":"python_api/#optisim.ThinLens-attributes","title":"Attributes","text":""},{"location":"python_api/#optisim.ThinLens.__doc__","title":"__doc__  <code>class</code>","text":"<pre><code>__doc__ = 'Represents an idealized thin lens.'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.</p>"},{"location":"python_api/#optisim.ThinLens.__module__","title":"__module__  <code>class</code>","text":"<pre><code>__module__ = 'optisim'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.</p>"},{"location":"python_api/#optisim.ThinLens-functions","title":"Functions","text":""},{"location":"python_api/#optisim.ThinLens.Calculate","title":"Calculate  <code>method descriptor</code>","text":"<pre><code>Calculate()\n</code></pre> <p>Calculate(self: optisim.ThinLens, imaging_subject: ImagingSubject) -&gt; Image</p> <p>Calculates the image formed by the thin lens for a given imaging subject.</p>"},{"location":"python_api/#optisim.ThinLens.__init__","title":"__init__  <code>method descriptor</code>","text":"<pre><code>__init__()\n</code></pre> <p>init(self: optisim.ThinLens, x: float, f: float) -&gt; None</p> <p>Initializes a ThinLens with a specified X-coordinate and focal length.</p>"},{"location":"python_api/#optisim.ThinLens.setF","title":"setF  <code>method descriptor</code>","text":"<pre><code>setF()\n</code></pre> <p>setF(self: optisim.ThinLens, f: float) -&gt; None</p> <p>Sets the focal length of the thin lens.</p>"},{"location":"requirement/","title":"Requirements","text":"<p>This document outlines the essential software, tools, and hardware required to successfully build, run, and contribute to the project.</p>"},{"location":"requirement/#1-operating-system","title":"1. Operating System","text":"<ul> <li>Linux: Ubuntu 22.04 LTS (Jammy Jellyfish) or higher.</li> </ul>"},{"location":"requirement/#2-hardware-dependencies","title":"2. Hardware Dependencies","text":"<ul> <li>RAM: 8 GB or more recommended.</li> <li>CPU: Multi-core processor recommended.</li> </ul>"},{"location":"requirement/#3-core-build-runtime-dependencies","title":"3. Core Build &amp; Runtime Dependencies","text":"<ul> <li>C++ Compiler: GCC/G++ 11.0 or higher.</li> <li>Python: 3.12 or higher.</li> <li>Java JDK: Version 17 (LTS) or higher.</li> <li>CMake: 3.15 or higher.</li> <li>Git: 2.25.0 or higher.</li> </ul>"},{"location":"requirement/#4-python-environment-and-libraries","title":"4. Python Environment and Libraries","text":"<ul> <li>JPype: 1.0.0 or higher.</li> <li>Pybind11: 2.10.0 or higher.</li> </ul>"},{"location":"requirement/#5-development-tools-for-developers","title":"5. Development Tools (For Developers)","text":"<ul> <li>Doxygen: 1.9.1 or higher.</li> <li>MkDocs: 1.5.0 or higher.</li> </ul>"},{"location":"user_guide/","title":"Optical System Simulator GUI","text":"<p>This application provides a user-friendly graphical interface for designing, visualizing, and simulating optical systems.</p>"},{"location":"user_guide/#key-features","title":"Key Features:","text":"<ul> <li>Intuitive Layout: The GUI is divided into two main sections:<ul> <li>Left Panel: Contains control buttons and a list of all optical elements in the current system.</li> <li>Right Panel: Displays a visual representation of the optical system and the resulting image formation.</li> </ul> </li> <li>Default Light Source: Every new system starts with a default light source/object, forming the basis of your optical setup.</li> <li>System Management:<ul> <li>Load System: Import existing optical systems from <code>.json</code> files. Upon loading, elements automatically populate the list and visualization.</li> <li>Save System: Export your constructed optical systems as <code>.json</code> files for future use.</li> </ul> </li> <li>Element Addition: Easily add new optical elements to your system:<ul> <li>Thin Lenses: Define by name, position, and focal length.</li> <li>Thick Lenses: Define by name, position, refractive index, thickness, left radius, and right radius.</li> <li>Newly added elements are immediately reflected in both the element list and the visualization.</li> </ul> </li> <li>System Calculation: After constructing your system, click Calculate to visualize ray traces and the final image formation. The calculated image also appears in the element list.</li> <li>Element Modification:<ul> <li>Clicking on any optical element in the list opens a dedicated modification window.</li> <li>Adjust parameters or delete elements (except for the light source/object).</li> <li>The calculated image cannot be modified or deleted; its modification window only displays its parameters.</li> </ul> </li> <li>Dynamic Visualization:<ul> <li>The optical system visualization is automatically scaled to fit the window, with independent scaling for horizontal and vertical axes for optimal viewing.</li> <li>Image formation and ray traces are only displayed after calculation and disappear if any modifications are made to the system (e.g., adding or altering elements).</li> </ul> </li> </ul> <p>This simulator provides a comprehensive environment for experimenting with and understanding optical principles.</p>"},{"location":"video/","title":"\ud83c\udfac OptiSim Tutorial Video","text":"<p>Welcome to the official OptiSim tutorial!</p> <p>This video will walk you through everything you need to get started with OptiSim \u2014 from installation to using the GUI and integrating it as a C++ or Python library.</p>"},{"location":"video/#watch-the-video","title":"\ud83d\udcf9 Watch the Video","text":"<p>Click the thumbnail or watch on YouTube</p>"},{"location":"video/#what-youll-learn","title":"\ud83d\udcd6 What You'll Learn","text":"<p>In this tutorial, you'll see:</p> <ul> <li>\u2705 How to add lenses to the system </li> <li>\u2705 How to modify and delete optical elements</li> <li>\u2705 How to get information about the image.</li> <li>\u2705 How save or load a system from file.</li> </ul> <p>We hope you enjoy using OptiSim \u2014 and this video helps you get the most out of it!</p>"}]}